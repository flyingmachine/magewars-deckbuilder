(page "index.html"
  (:require [magewars-deckbuilder.deck :as d]
            [magewars-deckbuilder.filtering
             :as f :refer [filter-match filter-cards filter-options
                           attribute-filter-types empty-filters]]
            [tailrecursion.castra
             :as c :refer [mkremote]]))

(set! cljs.core/*print-fn* #(.log js/console %))

;; state
(def filter-attributes-ordered
  (reduce #(assoc % (second %2) (first %2))
          {}
          (map-indexed vector
                       [:type :subtypes :school :level
                        :targets :secondary-targets :range
                        :casting-cost :effects :traits
                        :speed :armor :life :channeling :defenses
                        :attack-dice :damage-types :ranged-melee :attack-speed
                        :slot])))
(defc filters (empty-filters attribute-filter-types))
(defc cards #{})
(defc error nil)
(def get-state (mkremote 'magewars-deckbuilder.api.deck/get-state cards error (cell nil)))
(defc= fcards (sort-by :name (filter-cards cards filters)))
(defc= foptions (sort-by #(get filter-attributes-ordered (first %)) (filter-options cards)))

;; 
(defn toggle-filter!
  [attr val]
  (fn []
    (let [f (if (get-in @filters [attr val]) disj conj)]
      (swap! filters #(merge-with f % {attr val})))))

(defn filter-applied?
  [attr val]
  (if-let [fvals (attr filters)]
    (fvals val)))

(defn filter-count
  [attr val]
  (let [c @fcards
        f @filters]
    (cell= (count
            (if (filter-applied? attr val)
              (filter #(filter-match attr val %) c)
              (filter #(filter-match attr val %) c))))))

(defn vset?
  [attr]
  (= (attr attribute-filter-types) :vset))
(defn filter-val-display [attr val] (if (vset? attr) (first val) val))

(defn sub-filters
  [attr val]
  (if (and (vset? attr) (not-empty (second val)))
    (let [[root leaves] val]
      (div (ul (map #(li
                      (input :type "checkbox"
                             :on-change (toggle-filter! attr [root %])))
                    (map str (second val))))))))


(defn filter-li
  [attr val display]
  (li
   (label
    (input :type "checkbox"
           :on-change (toggle-filter! attr val))
    (text "~{display} ~{@(filter-count attr val)}"))))
(defn filter-val
  [attr val]
  (if (vset? attr)
    (let [[root leaves] val]
      ((filter-li attr root root)
       (if (> (count leaves) 0)
         (ul (map #(filter-li attr [root %] %) leaves)))))
    (filter-li attr val val)))
(defn filter-attribute
  [attr vals]
  (div (h3 (text "~{attr}"))
       (ul (map (partial filter-val attr) vals))))

(defn add-card
  [dest c]
  (let [count {:count 1}]
    (if-let [found (some #(and (= (:name %) (:name c)) %) dest)]
      (conj (disj dest found) (merge-with + found count))
      (conj dest (merge c count)))))
(defn remove-card
  [src c]
  (into (disj src c)
        (if (> (:count c) 1)
          [(merge-with - c {:count 1})])))

(defn move-card
  [card src dest]
  (fn []
    (let [c @card]
      (swap! src remove-card c)
      (swap! dest add-card c))))

(get-state)

(defn fc
  [vals]
  (div (text "~{vals}")))

(html
 (head)
 (body
   (h1 "Mage Wars Deck Builder")
   (div :id "deck"
     (h3 "Filters")
     (loop-tpl :size (count filter-attributes-ordered)
               :bindings [foption foptions]
       (filter-attribute (first @foption) (sort (second @foption))))
     (h3 "Cards")
     (ul
       (loop-tpl :size 300 :bindings [card fcards]
         (li (text "~{(:name card)}")))))))
